#!/bin/sh
# vim:noexpandtab


# Default values go here.  It is important to _not_ initialize some
# variables here.  They are:
#
# PM_CMDLINE
# RESUME_MODULES
#
# for great debugging!
[ "${PM_DEBUG}" = "true" ] && {
	export PM_DEBUG
	set -x
}
set -a
PM_UTILS_LIBDIR="@PM-UTILS-LIBDIR@"
PM_UTILS_ETCDIR="@PM-UTILS-SYSCONFDIR@"
PM_UTILS_RUNDIR="/var/run/pm-utils"
PM_CMDLINE="$*"

PATH=/sbin:/usr/sbin:/bin:/usr/bin:"${PM_UTILS_LIBDIR}"/bin
HIBERNATE_MODE="platform"
HIBERNATE_RESUME_POST_VIDEO=no
INHIBIT="${PM_UTILS_RUNDIR}/inhibit"
PM_LOGFILE="${PM_LOGFILE:=/var/log/pm-suspend.log}"
SUSPEND_MODULES=""
TEMPORARY_CPUFREQ_GOVERNOR="performance"
LOCKDIR="${PM_UTILS_RUNDIR}/locks"
STORAGEDIR="${PM_UTILS_RUNDIR}/storage"
SLEEP_MODULE="kernel"
NA=254
NX=253
DX=252
PM_FUNCTIONS="$PM_UTILS_LIBDIR/functions"
# Use c sort order
export LC_COLLATE=C

[ -f "${PM_UTILS_LIBDIR}"/defaults ] && . "${PM_UTILS_LIBDIR}"/defaults

set +a

for cfg in "${PM_UTILS_ETCDIR}"/config.d/*[!~] ; do
	[ -f "$cfg" ] || continue
	set -a
	. "${cfg}"
	set +a
done

. "${PM_FUNCTIONS}"

load_hook_blacklist()
{
	[ -f "$PM_UTILS_ETCDIR/blacklist" ] || return
	# loop through the blacklist file, adding entries to our hook blacklist.
	# Blacklist file format:
	# name debugging text
	# Comments begin with hash signs.
	sed 's,#.*$,,g' < "$PM_UTILS_ETCDIR/blacklist" | \
	while read entry comment; do
		# skip blank lines
		[ -z "$entry" ] && continue
		disablehook "${entry##*/}" "${comment:-blacklist}"
	done
}

load_hook_parameters()
{
	[ -f "$PM_UTILS_ETCDIR/parameters" ] || return
	# loop through the parameters file, and add each line in it to the
	# end of PM_CMDLINE.
	# Comments begin with hashmarks and run to the end of the line.
	# Because we are modifying an env var, the while read loop cannot
	# run in a pipe like the previous one did.
	while read parameter; do
		parameter="$(echo $parameter |sed 's,#.*$,,g')"
		[ -z "$parameter" ] && continue
		PM_CMDLINE="${PM_CMDLINE} $parameter"
	done < "$PM_UTILS_ETCDIR/parameters"
}

log() { [ $LOGGING ] && echo $*; }

take_suspend_lock()
{
	try_lock "pm-utils.lock" || return 1
	mkdir -p "${STORAGEDIR}"
	load_hook_blacklist
	load_hook_parameters
	return 0
}

remove_suspend_lock()
{
	local curr_vt=$(fgconsole)
	[ "$curr_vt" = "$VT" ] || chvt "$VT"
	rm -rf "${STORAGEDIR}"
	release_lock "pm-utils.lock"
}

hook_exit_status(){
	case $1 in
		0) log "success." ;;
		$NA) log "not applicable." ;;
		$NX) log "not executable." ;;
		$DX) log "disabled." ;;
		*) log "Returned exit code $1." ;;
	esac
}

hook_ok()
{
	local hook="${1##*/}"
	## the actual name as passed to us.
	[ -f "$STORAGEDIR/disable_hook:$hook" ] && return $DX
	## name with zeros chopped off the filename
	[ -f "$STORAGEDIR/disable_hook:${hook#[0-9][0-9]}" ] && return $DX
	[ -x "$1" ] || return $NX
	return 0
}

run_hooks() {
	# $1 = type of hook to find.  
	# $2 = paramaters to pass to hooks.
	# $3 = if present and equal to "reverse", run hooks backwards.
	# Currently only power and sleep are meaningful.
	local syshooks="${PM_UTILS_ETCDIR}/$1.d"
	local phooks="${PM_UTILS_LIBDIR}/$1.d"
	command_exists before_hooks && before_hooks
	local sort="sort"
	local base
	local hook
	local oifs="${IFS}"
	# the next two lines are not a typo or a formatting error!
	local nifs="
"
	IFS="${nifs}" # tolerate spaces in filenames.
	[ "$3" = "reverse" ] && sort="sort -r"
	for base in $(IFS="${oifs}"; for f in "$syshooks/"*[!~] "$phooks/"*[!~];
		do [ -O "$f" ] && echo ${f##*/} ; done | $sort | uniq) ;
	do
		if [ -f "$syshooks/$base" ]; then
			hook="$syshooks/$base"
		elif [ -f "$phooks/$base" ]; then
			hook="$phooks/$base"
		fi
		log  $(date): running ${hook} $2
		hook_ok "$hook" && (
			IFS="${oifs}"
			"${hook}" $2
		)
		hook_exit_status $?
	done
	IFS="${oifs}"
}

init_logfile()
{
	if [ -h "$1" ]; then
		echo "$1 is a symbolic link, refusing to overwrite."
		return 1
	elif [ ! -O "$1" ]; then
		echo "We do not own $1, refusing to overwrite."
		return 1
	elif [ -z "$1" ]; then
		echo "Please pass a filename to init_logfile."
		return 1
	fi
	export LOGGING=true
	exec > "$1" 2>&1
}


SLEEP_FUNCTIONS="${PM_UTILS_LIBDIR}/module.d/${SLEEP_MODULE}"
[ -f "${SLEEP_FUNCTIONS}" ] || { 
	echo "Requested sleep module $SLEEP_MODULE not available."
	exit 1
}

. "${SLEEP_FUNCTIONS}"

