#!/bin/sh
# vim:noexpandtab


# Default values go here.  It is important to _not_ initialize some
# variables here.  They are:
#
# PM_CMDLINE
# RESUME_MODULES
#
# for great debugging!
[ "${PM_DEBUG}" = "true" ] && {
	export PM_DEBUG
	set -x
}
set -a
PM_UTILS_LIBDIR="@PM-UTILS-LIBDIR@"
PM_UTILS_ETCDIR="@PM-UTILS-SYSCONFDIR@"
PM_UTILS_RUNDIR="/var/run/pm-utils"

PATH=/sbin:/usr/sbin:/bin:/usr/bin:"${PM_UTILS_LIBDIR}"/bin
INHIBIT="${PM_UTILS_RUNDIR}/inhibit"
PM_LOGFILE="${PM_LOGFILE:=/var/log/pm-suspend.log}"
TEMPORARY_CPUFREQ_GOVERNOR="performance"
LOCKDIR="${PM_UTILS_RUNDIR}/locks"
STORAGEDIR="${PM_UTILS_RUNDIR}/storage"
NA=254
NX=253
DX=252
PM_FUNCTIONS="$PM_UTILS_LIBDIR/functions"
# Use c sort order
LC_COLLATE=C

# These should be overridden by defaults and/or config.d settings.
# Specifically, distros should override these by modifying defaults,
# and end users should modify these using files in /etc/pm/config.
HIBERNATE_MODE=""
HIBERNATE_RESUME_POST_VIDEO="no"
SLEEP_MODULE="kernel"
# These variables will be handled specially when we load the config file.
SUSPEND_MODULES=""
HOOK_BLACKLIST=""
ADD_PARAMETERS=""
DROP_PARAMETERS=""

[ -f "${PM_UTILS_LIBDIR}"/defaults ] && . "${PM_UTILS_LIBDIR}"/defaults

set +a

# save our parameter list. Second stupidest way of doing this.
for x in "$@"; do
    touch "${STORAGEDIR}/parm:${x}"
done

for cfg in "${PM_UTILS_ETCDIR}"/config.d/*[!~] ; do
	[ -f "$cfg" ] || continue
	# Ugly, I know. The goal here is to allow multiple files in
	# /etc/pm/config.d declare these variables and have those 
	# declarations add together instead of the last one overwriting
	# all the others.
	[ "$SUSPEND_MODULES" ] && REAL_SUSPEND_MODULES="$SUSPEND_MODULES"
	[ "$HOOK_BLACKLIST" ] && REAL_HOOK_BLACKLIST="$HOOK_BLACKLIST"
	[ "$ADD_PARAMETERS" ] && REAL_ADD_PARAMETERS="$ADD_PARAMETERS"
	[ "$DROP_PARAMETERS" ] && REAL_DROP_PARAMETERS="$DROP_PARAMETERS"
	set -a
	. "${cfg}"
	SUSPEND_MODULES="$REAL_SUSPEND_MODULES $SUSPEND_MODULES"
	HOOK_BLACKLIST="$REAL_HOOK_BLACKLIST $HOOK_BLACKLIST"
	ADD_PARAMETERS="$REAL_ADD_PARAMETERS $ADD_PARAMETERS"
	DROP_PARAMETERS="$REAL_DROP_PARAMETERS $DROP_PARAMETERS"
	set +a
done

. "${PM_FUNCTIONS}"

# Simple little logging function.
# We do it this way because 'echo -n' is not posix.
log()
{
	[ $LOGGING ] || return;
	local fmt='%s\n'
	[ "$1" = "-n" ] && { fmt='%s'; shift; }
	printf "$fmt" "$*"
}

# update PM_CMDLINE iff someone changed our parameters
update_parameters()
{
	[ -f "${STORAGEDIR}/new-parm" ] || return
	export PM_CMDLINE="$(get_parameters)"
	rm "${STORAGEDIR}/new-parm"
}


# if the user asked us to blacklist any hooks, do it.
load_hook_blacklist()
{
	[ "$HOOK_BLACKLIST" ] || return
	local hook
	for hook in $HOOK_BLACKLIST; do
		disablehook "${hook}" "blacklisted by user"
		log "Blacklisting ${hook}."
	done
}

load_hook_parameters()
{
	[ "$DROP_PARAMETERS" ] && remove_parameters $DROP_PARAMETERS
	[ "$ADD_PARAMETERS" ]  && add_parameters $ADD_PARAMETERS
	update_parameters
}

take_suspend_lock()
{
	try_lock "pm-utils.lock" || return 1
	mkdir -p "${STORAGEDIR}"
	return 0
}

remove_suspend_lock()
{
	rm -rf "${STORAGEDIR}"
	release_lock "pm-utils.lock"
}

hook_exit_status(){
	case $1 in
		0)   log "success." ;;
		$NA) log "not applicable." ;;
		$NX) log "not executable." ;;
		$DX) log "disabled." ;;
		*)   log "Returned exit code $1." ;;
	esac
}

# check to see if a hook is a candidate for being run.
hook_ok()
{
	local hook="${1##*/}"
	# the actual name as passed to us.
	[ -f "$STORAGEDIR/disable_hook:$hook" ] && return $DX
	# name with leading digits chopped off the filename
	[ -f "$STORAGEDIR/disable_hook:${hook#[0-9][0-9]}" ] && return $DX
	[ -x "$1" ] || return $NX
	return 0
}

# Run all applicable hooks, logging success and failure as we go.
run_hooks() {
	# $1 = type of hook to find.  
	# $2 = paramaters to pass to hooks.
	# $3 = if present and equal to "reverse", run hooks backwards.
	# Currently only power and sleep are meaningful.
	local syshooks="${PM_UTILS_ETCDIR}/$1.d"
	local phooks="${PM_UTILS_LIBDIR}/$1.d"
	command_exists before_hooks && before_hooks
	local sort="sort"
	local base
	local hook
	local oifs="${IFS}"
	# the next two lines are not a typo or a formatting error!
	local nifs="
"
	IFS="${nifs}" # tolerate spaces in filenames.
	[ "$3" = "reverse" ] && sort="sort -r"
	for base in $(IFS="${oifs}"; for f in "$syshooks/"*[!~] "$phooks/"*[!~];
		do [ -O "$f" ] && echo ${f##*/} ; done | $sort | uniq) ;
	do
		IFS="${oifs}"
		if [ -f "$syshooks/$base" ]; then
			hook="$syshooks/$base"
		elif [ -f "$phooks/$base" ]; then
			hook="$phooks/$base"
		fi
		log -n "${hook} $2: "
		hook_ok "$hook" && "${hook}" $2
		hook_exit_status $?
		update_parameters
		IFS="${nifs}"
	done
	IFS="${oifs}"
}

# Try to reinitalize the logfile. Fail unless certian criteria are met.
init_logfile()
{
	if [ -z "$1" ]; then
		echo "Please pass a filename to init_logfile."
		return 1	
	elif [ -h "$1" ]; then
		echo "$1 is a symbolic link, refusing to overwrite."
		return 1
	elif [ -f "$1" -a ! -O "$1"  ]; then
		echo "We do not own $1, refusing to overwrite."
		return 1
	fi
	export LOGGING=true
	exec > "$1" 2>&1
}


SLEEP_FUNCTIONS="${PM_UTILS_LIBDIR}/module.d/${SLEEP_MODULE}"
[ -f "${SLEEP_FUNCTIONS}" ] || { 
	echo "Requested sleep module $SLEEP_MODULE not available."
	exit 1
}

. "${SLEEP_FUNCTIONS}"

